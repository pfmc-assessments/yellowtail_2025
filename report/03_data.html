<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>data</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="03_data_files/libs/clipboard/clipboard.min.js"></script>
<script src="03_data_files/libs/quarto-html/quarto.js"></script>
<script src="03_data_files/libs/quarto-html/popper.min.js"></script>
<script src="03_data_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="03_data_files/libs/quarto-html/anchor.min.js"></script>
<link href="03_data_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="03_data_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="03_data_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="03_data_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="03_data_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="data" class="level1">
<h1>Data</h1>
<!--- Provide temporal and spatial resolutions or sample size where appropriate for each of the subsections, below.--->
<section id="fishery-dependent-data" class="level2">
<h2 class="anchored" data-anchor-id="fishery-dependent-data">Fishery-dependent data</h2>
<!-- Commercial fisheries landings by state, year, and gear (PacFIN is the standard source for recent domestic commercial landings), historical catch estimates, discards, recreational fisheries catches, foreign removals; sample size information for length- and age-composition data by state, year and gear, including both the number of trips and fish sampled. Description of methods to estimate abundance indices, sample size information by survey and year. Include complete tables and figures and date of data extraction. -->
<section id="landings" class="level3">
<h3 class="anchored" data-anchor-id="landings">Landings</h3>
</section>
<section id="discards" class="level3">
<h3 class="anchored" data-anchor-id="discards">Discards</h3>
</section>
<section id="biological-data" class="level3">
<h3 class="anchored" data-anchor-id="biological-data">Biological data</h3>
</section>
<section id="abundance-indices" class="level3">
<h3 class="anchored" data-anchor-id="abundance-indices">Abundance indices</h3>
<section id="oregon-orbs-dockside-index-2001---2024" class="level4">
<h4 class="anchored" data-anchor-id="oregon-orbs-dockside-index-2001---2024">Oregon ORBS Dockside Index (2001 - 2024)</h4>
<p>Trip-level catch-per-unit-effort data from ORBS dockside sampling was obtained from ODFW. To mitigate the confounding of hourly effort associated with these trips with travel, the travel time was subtracted from the hours fished. Travel time was stratified by boat type (charter and private) and was calculated as boat type-specific speeds (13 mph for charter boat trips and 18 mph for private boat trips) multiplied by twice the distance between the port of origin and the reef that was fished. CPUE, expressed in terms of fish per angler-hour, was calculated by multiplying the number of anglers and the adjusted travel time. The database contains information on catch by species (number of retained fish), effort (angler hours), sample location (port where data were collected), date, bag limits and other relevant regulations, boat type (charter or private), and trip type (e.g., bottom associated fish).</p>
<p>The unfiltered data set contained 456,172 trips from 2001 - 2024. Multiple standardized filters are applied to ORBS trip-level data to remove outliers and data unsuitable for an index. These filters include trips with incorrect interview times, which impact calculation of effort, unreasonably long or short trips, and retaining only bottomfish target trips. Further filters were utilized for fishing closures (i.e.&nbsp;temporal or spatial closures) and catches exceeding bag limits, which would presumably impact catch rates. Trips from several ports with extremely small sample sizes (&lt;1% of total trips) were also excluded and finally, trips that met criteria for irrational effort reporting (i.e., implausible values) or extreme catch rates were excluded as well. The final dataset included 137,502 trips (TABLE “percent_pos.csv”).</p>
<p>Covariates evaluated included year, month, port, the open depths to fishing (all depths or inside 20/30/40fm), boat type and the daily bag limit for Yellowtail Rockfish. Preliminary model explorations indicated that the daily bag limit covariate could not be combined with the open depth of the fishery due to changes in recreational fishing regulations over time. Prior to 2017, Yellowtail Rockfish were included in the general marine bag limit. However, in 2017, Yellowtail Rockfish were also included in a specialized longleader recreational bag limit where participants were required to be outside of 40fm. As a result, the bag limits were binned into a binary covariate for low (5 – 8 fish) and high (10 – 15fish) bag limits during the 2001 – 2024 time period. Negative binomial models were fit in sdmTMB (Version 0.6.0) to the trip-level data (catch with a log offset for adjusted angler hours). Tweedie distributions were also explored for selected models but generally did not improve model diagnostics. The final model selected includes year, month, port, open fishery depths, longleader trip and binned target bag limit covariates, which was the best fit model by AIC in this series (TABLE “model_selection.csv”). Acceptable diagnostics for the model were achieved (FIGURE – qqplot) and the negative binomial distribution was preferred over the tweedie. The index of abundance are shown in Figure/Table XXXX.</p>
</section>
</section>
</section>
<section id="fishery-independent-data" class="level2">
<h2 class="anchored" data-anchor-id="fishery-independent-data">Fishery-independent data</h2>
<section id="abundance-indices-1" class="level3">
<h3 class="anchored" data-anchor-id="abundance-indices-1">Abundance Indices</h3>
<section id="smurf-yoy-index" class="level4">
<h4 class="anchored" data-anchor-id="smurf-yoy-index">SMURF YOY Index</h4>
<p>ODFW and Oregon State University (OSU) have collaborated on young of the year (YOY) fish and environmental monitoring in and around Oregon Marine Reserves (MR) using SMURF devices, standardized sampling units that collect newly-settled juvenile fishes. Data were provided for two regions on the Oregon coast, near the Otter Rock MR (central) and the Redfish Rocks MR (southern) with a site inside of the reserve and a comparison site outside of the reserve from 2011 to the present. These are monitored regularly (approximately every 2 weeks) during the settlement season (April - September) and YOY are collected for genetic identification and measured. Settlement rate of YOY Yellowtail Rockfish was provided by OSU for each site within each region. Paired temperature at depth data was provided by ODFW MR Ecological Monitoring team for this assessment. Daily mean temperature data was provided for three depth strata (1m, 7.5m, and 15m) for each site within each region.</p>
<p>Oceanographic sampling by the ODFW MR Ecological Monitoring team has not been able to be done simultaneously in both reserves at each mooring site at all depths due to a lack of equipment. However, for time periods when there was matched data, temperature was highly correlated across depths (Pearson’s correlation coefficient &gt; 0.90) and between sites within each region (Pearson’s correlation coefficients &gt;0.98). In order to calculate an index of daily water column temperature that was continuous enough to be combined with settlement rate data, temperature data was standardized within year and depth. For periods with multiple observations, the mean was taken in order to generate a single continuous temperature time series. Mean SMURF deployment lasted 15.5 days. In order to summarize temperature in an ecologically meaningful way relative to the SMURF sampling design, a 16-day rolling mean of temperature and cumulative degree days over 16-day periods were calculated. These data were matched with settlement rate data such that the mean temperature or the cumulative degree days during the 16-day period that the SMURF was deployed was used.</p>
<p>Covariates evaluated for were year, month, region (Redfish Rocks or Otter Rock), temperature, and site (within marine reserve or nearby comparison site). Preliminary model runs indicated a consistent lack of convergence and additional filters were applied to address this, including limiting the data to 2014 - 2024 and to the peak months of settlement for yellowtail (May - July). Month was not included in models that included temperature as both covariates were used to describe seasonal variation in settlement rate. Site was not a significant covariate in this model but this was not unexpected, as the presence of a reserve would not be anticipated to impact juvenile settlement rates. Models were fit to the settlement rate data (YOY fish per day) using sdmTMB R package (Version 0.6.0). Both negative binomial and tweedie distributions were evaluated. The model that was selected based on fit (TABLE X) and expert opinion from OSU and ODFW staff. The final model contained year, region, and temperature summarized as cumulative degree days 16-days prior to SMURF recovery using a negative binomial distribution. Acceptable model convergence and other diagnostic criteria for the final index were achieved (FIGURE - qqplot). The index of YOY abundance and associated standard errors are shown in Figure/Table Y.</p>
</section>
</section>
</section>
<section id="biological-parameters" class="level2">
<h2 class="anchored" data-anchor-id="biological-parameters">Biological Parameters</h2>
<section id="natural-mortality" class="level3">
<h3 class="anchored" data-anchor-id="natural-mortality">Natural Mortality</h3>
</section>
<section id="weight-at-length" class="level3">
<h3 class="anchored" data-anchor-id="weight-at-length">Weight-at-length</h3>
</section>
<section id="maturity" class="level3">
<h3 class="anchored" data-anchor-id="maturity">Maturity</h3>
<p>We used a total of 292 individual histological samples of aged female yellowtail rockfish to estimate maturity for the assessment. These samples were all collected north of 40.167; this latitude filter excluded 5 additional samples collected in the south, but the inclusion or exclusion of these samples did not change our results. The 292 samples were collected over the period 2016—2023, though more samples were collected earlier in these years (n = 111 in 2016, 52 in 2017, 31 in 2018, 17 in 2021, 9 in 2022, 13 in 2023). Previous assessments of yellowtail estimated length-based maturity (L50 = 42.49cm in 2017 assessment); however, we switched to an age based model for the current assessment. For many species, energy is reallocated toward maturation from growth, and as a result growth rates slow during the juvenile to adult transition period. Thus, length at 50% maturity will represent a range of ages, providing a less accurate understanding of the spawning population. We treated maturity as a binomial response, and considered a variety of models with temporal and spatial covariates, using a logit link and generalized linear mixed model framework, implemented the R package sdmTMB <span class="citation" data-cites="Anderson:2024:SRP">[@Anderson:2024:SRP]</span>. Briefly, we considered models that included (1) temporal year effects (either estimated as a random walk intercept, or smooth term), (2) spatial random fields (using a mesh cutoff distance of 50km), and (3) spatially varying coefficients of age, following the model adopted by Grandin et al. <span class="citation" data-cites="grandin_status_2024">[-@grandin_status_2024]</span>. Models that converged were compared by examining QQ plots, AUC metrics, and AIC scores. Likely because of the uneven temporal distribution of sampling, and general sparsity, we did not find support for including temporal or spatial effects, and decided on the simpler null model (equivalent to a logistic regression). For the age-based model, we estimated an intercept of -6.70 (SE = 0.99) and slope of 0.67 (SE = 0.10), equivalent to an A50 of 10.0 years. For a more direct comparison to the previous assessment, we used these same 292 samples to fit an equivalent length – based model, which resulted in an estimated L50 = 42.5 cm.</p>
</section>
<section id="fecundity" class="level3">
<h3 class="anchored" data-anchor-id="fecundity">Fecundity</h3>
</section>
</section>
<section id="environmental-and-ecosystem-data" class="level2">
<h2 class="anchored" data-anchor-id="environmental-and-ecosystem-data">Environmental and ecosystem data</h2>
<section id="oceanographic-index" class="level3">
<h3 class="anchored" data-anchor-id="oceanographic-index">Oceanographic Index</h3>
<p>Over the past several years, progress has been made in understanding how oceanographic conditions drive recruitment of groundfish species in the California Current Ecosystem across lifestages including petrale sole, sablefish and hake. Recent increases in capacity supported by the Climate, Ecosystem, and Fisheries Initiative provided the ability to build on these previous lines of research and examine the relationship between northern Yellowtail rockfish recruitment and oceanographic drivers based on model output from Global Ocean Physics Reanalysis (GLORYS) from <a href="https://marine.copernicus.eu/">Copernicus Marine Environment Monitoring Service</a> (CMEMS) and Regional Ocean Modeling System (ROMS) model for the California Current Ecosystem (Neveu et al.&nbsp;2016). The results suggest that GLORYS and ROMS output may allow for better model precision and near-term forecasting. This approach builds on previous research (Tolimieri et al.&nbsp;2020, Haltuch et al.&nbsp;2020, Vestfals et al.&nbsp;2023) and assessments (Taylor et al.&nbsp;2023, Johnson et al.&nbsp;2023) by applying similar techniques to establish oceanographic relationships and develop an oceanographic index based on a conceptual life history model for yellowtail rockfish (Darby et al.&nbsp;in prep). GLORYS also provides a temporally robust time series and is not susceptible to discontinuities identified in the 2023 petrale sole assessment. Appendix A of this report describes the most recent efforts in developing a new environmental index of northern Yellowtail recruitment based on GLORYS products. The final selected model included the date of spring transition from the Coastal Upwelling Transport Index, degree days (represent temperature exposure) during egg fertilization and development, long-shore transport during the pelagic juvenile lifestage, and El Nino conditions during the pelagic juvenile lifestage. The oceanographic model was fit using the recruitment deviations (1994 - 2019) from the base model and used to predict log recruitment deviations 5 years ahead, 2020 - 2024, using oceanographic conditions.</p>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>